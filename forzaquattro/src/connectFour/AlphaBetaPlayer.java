package connectFour;
/**
 * AlphaBetaPlayer.java
 *
 * File generated from the ConnectFour::AlphaBetaPlayer uml Class
 * Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
 * $ Date : 23/04/10 15.19.33 (23 aprile 2010) $
 */

/**
 * Description of the class AlphaBetaPlayer.
 * Classe che implementa un AIPlayerInterface che utilizza l'algoritmo Alpha Beta Pruning
 */

public class AlphaBetaPlayer implements AIPlayerInterface {
		
    private final Integer maxUtilityValue = 150;
    private Integer playerId;
    private Heuristic heuristic = new Heuristic();
    private Integer horizon = 0;
    private Integer examinatedNodeNumber = 0;

    /**
     * Constructor.
     */
    public AlphaBetaPlayer(Integer playerId) {
        setPlayerId(playerId);
    }

    public AlphaBetaPlayer(Integer playerId, Integer horizon) {
        this(playerId);
        if(horizon>0)setHorizon(horizon);
    }

    @Override
    public Integer getExaminatedNodeNumber() {
            return examinatedNodeNumber;
    }

    /**
     * metodo che determina la prossima mossa da eseguire e restituisce il nuovo stato
     * @param gameState Stato attuale del gioco
     * @return nuovo stato raggiunto applicando la mossa scelta
     */
    @Override
    public GameState nextMove(GameState gameState) {
        this.setExaminatedNodeNumber(0);
        if(this.horizon==null) return gameState;
        return nextMove(gameState, this.horizon);
    }

    /**
     * metodo che esegue l'algoritmo Alpha Beta Pruning con orizzonte
     * @param gameState Stato attuale del gioco
     * @param horizon intero che rappresenta il numero di livelli da sviluppare
     * @return nuovo stato
     */
    public GameState nextMove(GameState gameState, Integer horizon) {
        ValueStatePair maxValueStatePair = maxValue(gameState, (-1)*this.maxUtilityValue-1, this.maxUtilityValue+1, horizon);
        return maxValueStatePair.getState();
    }

    /**
     * maxvalue, procedura ausiliaria al calcolo della prossima mossa con
     * l'algoritmo Alpha Beta Pruning
     * @param gameState stato da esaminare
     * @param alpha
     * @param beta
     * @param horizon intero che rappresenta il numero di livelli che è ancora
     * possibile esaminare
     * @return una coppia Valore-Stato, contenente il max value e lo stato
     * corrispondente
     */
    private ValueStatePair maxValue(GameState gameState, Integer alpha, Integer beta, Integer horizon){
        // incrementa il numero di nodi esaminati
        setExaminatedNodeNumber(this.examinatedNodeNumber+1);

        // CONTROLLO DI TERMINAZIONE: se lo stato è terminale si valuta la funzione di utilità
        if(gameState.isTerminal())return new ValueStatePair(utility(gameState),gameState);

        /**
         * CONTROLLO SULL'ORIZZONTE: se abbiamo raggiunto l'orizzonte massimo
         * valutiamo la funzione euristica
         */
        if(horizon<=0)return new ValueStatePair(this.playerId*heuristic.calculateHeuristic(gameState),gameState);

        // calcolare il massimo degli stati successori e ritornarlo in output

        //inizializzazione del maxValue e del maxState
        Integer maxValue = (-1)*this.maxUtilityValue-1;
        GameState maxState = null;

        //ricerca dello stato con maxValue massimo
        for(Integer i=0;i<gameState.getColumns();i++){
            try{
                GameState succ = gameState.clone();

                // effettuiamo la mossa i
                if(succ.doMove(this.playerId, i)){

                    // calcoliamo il minValue dello stato ottenuto applicando la mossa i
                    ValueStatePair minValueStatePair = minValue(succ, alpha, beta, horizon-1);

                    // aggiorniamo, se necessario, il maxValue e il maxState
                    if(maxValue<minValueStatePair.getValue()){
                        maxValue=minValueStatePair.getValue();
                        maxState=succ;
                    }

                    // PRUNING
                    if (maxValue>=beta) return new ValueStatePair(maxValue, maxState);
                    alpha=Math.max(alpha, maxValue);
                }
            }catch(CloneNotSupportedException exc){
                exc.printStackTrace();
            }
        }

        return new ValueStatePair(maxValue, maxState);
    }

    /**
     * minvalue, procedura ausiliaria al calcolo della prossima mossa con
     * l'algoritmo Alpha Beta Pruning
     * @param gameState stato da esaminare
     * @param alpha
     * @param beta
     * @param horizon intero che rappresenta il numero di livelli che è ancora
     * possibile esaminare
     * @return una coppia Valore-Stato, contenente il min value e lo stato
     * corrispondente
     */
    private ValueStatePair minValue(GameState gameState, Integer alpha, Integer beta, Integer horizon){
        // incrementa il numero di nodi esaminati
        setExaminatedNodeNumber(this.examinatedNodeNumber+1);

        // CONTROLLO DI TERMINAZIONE: se lo stato è terminale si valuta la funzione di utilità
        if(gameState.isTerminal())return new ValueStatePair(utility(gameState),gameState);
                  
        /**
         * CONTROLLO SULL'ORIZZONTE: se abbiamo raggiunto l'orizzonte massimo
         * valutiamo la funzione euristica
         */
        if(horizon<=0)return new ValueStatePair(this.playerId*heuristic.calculateHeuristic(gameState),gameState);

        // calcolare il massimo degli stati successori e ritornarlo in output

        // inizializzazione del minValue e del minState
        Integer minValue = this.maxUtilityValue+1;
        GameState minState=null;

        //ricerca dello stato con minValue minimo
        for(Integer i=0;i<gameState.getColumns();i++){
            try{
                GameState succ = gameState.clone();

                // effettuiamo la mossa i
                if(succ.doMove(-1*this.playerId, i)){

                    // calcoliamo il maxValue dello stato ottenuto applicando la mossa i
                    ValueStatePair maxValueStatePair = maxValue(succ, alpha, beta, horizon-1);

                    // aggiorniamo, se necessario, il minValue e il minState
                    if(minValue>maxValueStatePair.getValue()){
                        minValue=maxValueStatePair.getValue();
                        minState=succ;
                    }

                    // PRUNING
                    if(minValue<=alpha) return new ValueStatePair(minValue, minState);
                    beta=Math.min(beta, minValue);
                }
            }catch(CloneNotSupportedException exc){
                exc.printStackTrace();
            }
        }

        return new ValueStatePair(minValue, minState);
    }

    /**
     * valuta la funzione di utilità
     * @param gameState stato di cui si vuole valutare la funzione di utilità
     * @return intero che rappresenta l'utilità dello stato
     */
    public Integer utility(GameState gameState){
        return this.maxUtilityValue*getPlayerId()*gameState.getWinner();
    }

    /**
     * @return the playerId
     */
    public Integer getPlayerId() {
        return playerId;
    }

    /**
     * @param playerId the playerId to set
     */
    public void setPlayerId(Integer playerId) {
        this.playerId = playerId;
    }

    /**
     * @return the horizon
     */
    public Integer getHorizon() {
        return horizon;
    }

    /**
     * @param horizon the horizon to set
     */
    public void setHorizon(Integer horizon) {
        this.horizon = horizon;
    }

    /**
     * @param examinatedNodeNumber the examinatedNodeNumber to set
     */
    private void setExaminatedNodeNumber(Integer examinatedNodeNumber) {
        this.examinatedNodeNumber = examinatedNodeNumber;
    }

}