package connectFour;

/**
 * AlphaBetaPlayer.java
 *
 * File generated from the ConnectFour::AlphaBetaPlayer uml Class
 * Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
 * $ Date : 23/04/10 15.19.33 (23 aprile 2010) $
 */

/**
 * Description of the class AlphaBetaPlayer.
 * Classe che implementa un AIPlayerInterface che utilizza l'algoritmo Alpha Beta Pruning
 */

public class AlphaBetaPlayer extends AIPlayerInterface {

    /**
     * Constructor
     */

    public AlphaBetaPlayer(Integer playerId, Integer horizon) {
        super(playerId, horizon);
    }

    @Override
    public GameState nextMove(GameState gameState) {
        setExaminatedNodeNumber(0);
        return nextMove(gameState, getHorizon());
    }

    /**
     * metodo che esegue l'algoritmo Alpha Beta Pruning con orizzonte
     * @param gameState Stato attuale del gioco
     * @param horizon intero che rappresenta il numero di livelli da sviluppare
     * @return nuovo stato
     */
    private GameState nextMove(GameState gameState, Integer horizon) {
        ValueMovePair maxValueMovePair = maxValueOptimized(gameState, (-1)*maxUtilityValue-1, maxUtilityValue+1, horizon);
        gameState.doMove(getPlayerId(), maxValueMovePair.getMove());
        return gameState;
    }
    
    /**
     * @deprecated maxvalue, procedura ausiliaria al calcolo della prossima mossa con
     * l'algoritmo Alpha Beta Pruning. Utilizzare maxValueOptimized
     * @param gameState stato da esaminare
     * @param alpha
     * @param beta
     * @param horizon intero che rappresenta il numero di livelli che è ancora
     * possibile esaminare
     * @return una coppia Valore-Stato, contenente il max value e lo stato
     * corrispondente
     */
    private ValueStatePair maxValue(GameState gameState, Integer alpha, Integer beta, Integer horizon){
        // incrementa il numero di nodi esaminati
        setExaminatedNodeNumber(getExaminatedNodeNumber()+1);

        // CONTROLLO DI TERMINAZIONE: se lo stato è terminale si valuta la funzione di utilità
        if(gameState.isTerminal()) return new ValueStatePair(utility(gameState),gameState);

        /**
         * CONTROLLO SULL'ORIZZONTE: se abbiamo raggiunto l'orizzonte massimo
         * valutiamo la funzione euristica
         */
        if(horizon<=0)return new ValueStatePair(getPlayerId()*getHeuristic().calculateHeuristic(gameState),gameState);

        // calcolare il massimo degli stati successori e ritornarlo in output

        //inizializzazione del maxValue e del maxState
        Integer maxValue = (-1)*maxUtilityValue-1;
        GameState maxState = null;

        //ricerca dello stato con maxValue massimo
        for(Integer i : getFromCenterNextMoves(gameState.getColumns())){
            try{
//                System.out.println("MOSSA "+i);
                GameState succ = gameState.clone();

                // effettuiamo la mossa i
                if(succ.doMove(getPlayerId(), i)){

                    // calcoliamo il minValue dello stato ottenuto applicando la mossa i
                    ValueStatePair minValueStatePair = minValue(succ, alpha, beta, horizon-1);

                    // aggiorniamo, se necessario, il maxValue e il maxState
                    if(maxValue<minValueStatePair.getValue()){
                        maxValue=minValueStatePair.getValue();
                        maxState=succ;
                    }

                    // PRUNING
                    if (maxValue>=beta) return new ValueStatePair(maxValue, maxState);
                    alpha=Math.max(alpha, maxValue);
                }
            }catch(CloneNotSupportedException exc){
                exc.printStackTrace();
            }
        }

        return new ValueStatePair(maxValue, maxState);
    }

    /**
     * @deprecated minvalue, procedura ausiliaria al calcolo della prossima mossa con
     * l'algoritmo Alpha Beta Pruning
     * @param gameState stato da esaminare
     * @param alpha
     * @param beta
     * @param horizon intero che rappresenta il numero di livelli che è ancora
     * possibile esaminare
     * @return una coppia Valore-Stato, contenente il min value e lo stato
     * corrispondente
     */
    private ValueStatePair minValue(GameState gameState, Integer alpha, Integer beta, Integer horizon){
        // incrementa il numero di nodi esaminati
        setExaminatedNodeNumber(getExaminatedNodeNumber()+1);

        // CONTROLLO DI TERMINAZIONE: se lo stato è terminale si valuta la funzione di utilità
        if(gameState.isTerminal()) return new ValueStatePair(utility(gameState),gameState);
                  
        /**
         * CONTROLLO SULL'ORIZZONTE: se abbiamo raggiunto l'orizzonte massimo
         * valutiamo la funzione euristica
         */
        if(horizon<=0)return new ValueStatePair(getPlayerId()*getHeuristic().calculateHeuristic(gameState),gameState);

        // calcolare il massimo degli stati successori e ritornarlo in output

        // inizializzazione del minValue e del minState
        Integer minValue = maxUtilityValue+1;
        GameState minState=null;

        //ricerca dello stato con minValue minimo
        for(Integer i : getFromCenterNextMoves(gameState.getColumns())){
            try{
                GameState succ = gameState.clone();

                // effettuiamo la mossa i
                if(succ.doMove(-1*getPlayerId(), i)){

                    // calcoliamo il maxValue dello stato ottenuto applicando la mossa i
                    ValueStatePair maxValueStatePair = maxValue(succ, alpha, beta, horizon-1);

                    // aggiorniamo, se necessario, il minValue e il minState
                    if(minValue>maxValueStatePair.getValue()){
                        minValue=maxValueStatePair.getValue();
                        minState=succ;
                    }

                    // PRUNING
                    if(minValue<=alpha) return new ValueStatePair(minValue, minState);
                    beta=Math.min(beta, minValue);
                }
            }catch(CloneNotSupportedException exc){
                exc.printStackTrace();
            }
        }

        return new ValueStatePair(minValue, minState);
    }


    /**
     * maxvalue ottimizzato, procedura ausiliaria al calcolo della prossima mossa con
     * l'algoritmo Alpha Beta Pruning
     * @param gameState stato da esaminare
     * @param alpha
     * @param beta
     * @param horizon intero che rappresenta il numero di livelli che è ancora
     * possibile esaminare
     * @return una coppia Valore-Stato, contenente il max value e lo stato
     * corrispondente
     */
    private ValueMovePair maxValueOptimized(GameState gameState, Integer alpha, Integer beta, Integer horizon){
        // incrementa il numero di nodi esaminati
        setExaminatedNodeNumber(getExaminatedNodeNumber()+1);

        // CONTROLLO DI TERMINAZIONE: se lo stato è terminale si valuta la funzione di utilità
        if(gameState.isTerminal()) return new ValueMovePair(utility(gameState),gameState.getMove());

        /**
         * CONTROLLO SULL'ORIZZONTE: se abbiamo raggiunto l'orizzonte massimo
         * valutiamo la funzione euristica
         */
        if(horizon<=0)return new ValueMovePair(getPlayerId()*getHeuristic().calculateHeuristic(gameState),gameState.getMove());

        // calcolare il massimo degli stati successori e ritornarlo in output

        //inizializzazione del maxValue e del maxState
        Integer maxValue = (-1)*maxUtilityValue-1;
        Integer maxMove = null;

        //ricerca dello stato con maxValue massimo
        for(Integer i : getFromCenterNextMoves(gameState.getColumns())){

            // effettuiamo la mossa i
            if(gameState.doMove(getPlayerId(), i)){

                // calcoliamo il minValue dello stato ottenuto applicando la mossa i
                ValueMovePair minValueMovePair = minValueOptimized(gameState, alpha, beta, horizon-1);

                // aggiorniamo, se necessario, il maxValue e il maxMove
                if(maxValue<minValueMovePair.getValue()){
                    maxValue=minValueMovePair.getValue();
                    maxMove=i;
                }

                // PRUNING
                if (maxValue>=beta) {
                    gameState.undo();
                    return new ValueMovePair(maxValue, maxMove);
                }
                alpha=Math.max(alpha, maxValue);

                //annullare la mossa
                gameState.undo();
            }
        }

        return new ValueMovePair(maxValue, maxMove);
    }

    /**
     * minvalue ottimizzato, procedura ausiliaria al calcolo della prossima mossa con
     * l'algoritmo Alpha Beta Pruning
     * @param gameState stato da esaminare
     * @param alpha
     * @param beta
     * @param horizon intero che rappresenta il numero di livelli che è ancora
     * possibile esaminare
     * @return una coppia Valore-Stato, contenente il min value e lo stato
     * corrispondente
     */
    private ValueMovePair minValueOptimized(GameState gameState, Integer alpha, Integer beta, Integer horizon){
        // incrementa il numero di nodi esaminati
        setExaminatedNodeNumber(getExaminatedNodeNumber()+1);

        // CONTROLLO DI TERMINAZIONE: se lo stato è terminale si valuta la funzione di utilità
        if(gameState.isTerminal()) return new ValueMovePair(utility(gameState),gameState.getMove());

        /**
         * CONTROLLO SULL'ORIZZONTE: se abbiamo raggiunto l'orizzonte massimo
         * valutiamo la funzione euristica
         */
        if(horizon<=0)return new ValueMovePair(getPlayerId()*getHeuristic().calculateHeuristic(gameState),gameState.getMove());

        // calcolare il massimo degli stati successori e ritornarlo in output

        // inizializzazione del minValue e del minState
        Integer minValue = maxUtilityValue+1;
        Integer minMove=null;

        //ricerca dello stato con minValue minimo
        for(Integer i : getFromCenterNextMoves(gameState.getColumns())){
            // effettuiamo la mossa i
            if(gameState.doMove(-1*getPlayerId(), i)){

                // calcoliamo il maxValue dello stato ottenuto applicando la mossa i
                ValueMovePair maxValueMovePair = maxValueOptimized(gameState, alpha, beta, horizon-1);

                // aggiorniamo, se necessario, il minValue e il minMove
                if(minValue>maxValueMovePair.getValue()){
                    minValue=maxValueMovePair.getValue();
                    minMove=i;
                }

                // PRUNING
                if(minValue<=alpha) {
                    gameState.undo();
                    return new ValueMovePair(minValue, minMove);
                }
                beta=Math.min(beta, minValue);

                //annullare la mossa
                gameState.undo();
            }
        }

        return new ValueMovePair(minValue, minMove);
    }

}
