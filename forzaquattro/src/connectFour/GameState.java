package connectFour;

import java.util.Stack;

/**
 * GameState.java
 *
 * File generated from the ConnectFour::GameState uml Class
 * Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
 * $ Date : 23/04/10 15.19.33 (23 aprile 2010) $
 */

/**
 * Description of the class GameState.
 * classe che tiene traccia dello stato del gioco
 */

/**
 * @author barnap
 *
 */
public class GameState implements Cloneable{

    /**
     * l'attributo board è una Matrice di interi che rappresenta il tavolo di gioco.
     * Ogni cella della matrice può contenere un valore tra:
     * 0 => cella vuota;
     * 1 => cella occupata da una pedina del giocatore giallo;
     * -1 => cella occupata da una pedina del giocatore rosso;
     */
    private Integer[][] board;
    private Integer rows;       // numero di righe della tabella
    private Integer columns;    // numero di colonne della tabella
    private Integer winner;     // intero che individua il vincitore della partita;
    private Integer player;     // intero che individua il giocatore che ha effettuato l'ultima mossa
    private Integer move;       // intero che individua l'ultima mossa effettuata

    private Stack<Integer> movesHistory;
    private Integer freeCells;  // numero di celle libere

    private Integer[] firstFreeCellForColumn;

    private Stack<HeuristicValues> heuristicValuesHistory;
    private HeuristicValues heuristicValues;
    /**
     * Constructor.
     */
    public GameState(){
        this(8,7);
    }

    public GameState(Integer rows, Integer columns){
        setRows(rows);
        setColumns(columns);
        setWinner(2);
        setPlayer(0);
        setMove(-1);
        movesHistory = new Stack<Integer>();
        heuristicValuesHistory = new Stack<HeuristicValues>();
        setFreeCells(rows*columns);
        board = new Integer[rows][columns];
        firstFreeCellForColumn = new Integer[columns];
        initializes();
        heuristicValues = new HeuristicValues();
    }

    public Integer getRows() {
        return rows;
    }

    private void setRows(Integer rows) {
        this.rows = rows;
    }

    public Integer getColumns() {
        return columns;
    }

    private void setColumns(Integer columns) {
        this.columns = columns;
    }

    /**
     * metodo per la verifica del vincitore
     * @return
     * -1 => ha vinto il giocatore rosso;
     * 0 => la partita è finita in pareggio;
     * 1 => ha vinto il giocatore giallo;
     * 2 => la partita non è ancora finita;
     */
    public Integer getWinner() {
        return winner;
    }

    private void setWinner(Integer winner) {
        this.winner = winner;
    }

    public Integer getMove(){
        return move;
    }

    private void setMove(Integer move) {
        this.move = move;
    }

    private void setPlayer(Integer player) {
        this.player = player;
    }

    public Integer getPlayer() {
        return player;
    }

    /**
     * metodo per effettuare le giocate
     * @param lastPlayer intero che rappresenta il giocatore di turno
     * @param column intero che rappresenta la colonna scelta dal giocatore
     * @return true se la mossa è stata effettuata con successo, false altrimenti
     */
    public Boolean doMove(Integer player, Integer column){
        Integer firstFreeRow=0;

        // se lo stato è terminale non sono applicabili altre mosse
        if(this.isTerminal()) return false;

        // cerca la riga in cui inserire la pedina nella colonna specificata
        firstFreeRow=this.firstFreeCellForColumn[column];

        // se la colonna è già piena non è possibile effettuare la mossa desiderata
        if(firstFreeRow>=this.rows) return false;

        //effettua la mossa e aggiorna lo stato del gioco
        board[firstFreeRow][column]=player;
        this.setPlayer(player);
        movesHistory.push(this.move);
        heuristicValuesHistory.push(this.getHeuristicValues()); //INVECE CHE UNO NUOVO: LA COPIA DEL VECCHIO
        this.heuristicValues=this.getHeuristicValues().clone();
        //IN QUESTO MOMENTO C'E' UN CLONE IN HEURISTICVALUES
//        heuristicValuesHistory.push(this.heuristicValues);
        this.setMove(column);
        this.setFreeCells(this.freeCells-1);
        this.firstFreeCellForColumn[column]=firstFreeRow+1;

        /* se c'è un vincitore oppure la partita è finita in pareggio aggiorna la
         * variabile winner
         */
//        if(hasWin(firstFreeRow, column))setWinner(player);
        if(hasWinWithEuristicValues(firstFreeRow, column))setWinner(player);

        // HAS WIN AGGIORNA HEURISTICVALUE
        else if(this.freeCells==0)setWinner(0);

        return true;
    }

    /**
     * annulla gli effetti dell'ultima mossa effettuata ripristinando lo stato
     * precedente
     * @return true se la mossa è stata effettuata con successo, false altrimenti
     */
    public Boolean undo(){
        Integer i;
        Integer lastPlayer=this.player;
        Integer column=this.move;
        
        i=this.firstFreeCellForColumn[column];

        //effettua la mossa e aggiorna lo stato del gioco
//        if(firstFreeRow<=0)System.out.println("firstFreeRow = "+firstFreeRow+" - column = "+column+" - STATO:\n"+this);
        board[i-1][column]=0;
        this.setPlayer(-1*lastPlayer);
        this.setMove(this.movesHistory.pop());
        this.heuristicValues=this.heuristicValuesHistory.pop();
        this.setFreeCells(this.freeCells+1);
        this.firstFreeCellForColumn[column]=i-1;
        setWinner(2);

        //aggiornare variabili eventuali per euristiche
        return true;
    }

//    public static void main(String[] args){
//        GameState gs=new GameState();
//
//        gs.doMove(1,3);
//        gs.doMove(-1,3);
//        gs.doMove(1,3);
//        gs.doMove(-1,3);
//        gs.doMove(1,3);
//        gs.doMove(-1,3);
//        gs.doMove(1,3);
//        gs.doMove(-1,3);
//        gs.doMove(1,3);
//        gs.doMove(-1,3);
//        System.out.println(gs);
//        gs.undo();
//        System.out.println(gs);
//
//    }

    /**
     * @deprecated
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWin2(Integer row, Integer column){
        Integer actualPlayer=this.getBoard()[row][column];
        Integer i;

        if(column<this.columns-3){
            //controlla a destra sulla riga
            i = 1;
            while(i <= 3 && this.getBoard()[row][i+column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;

            if(row<this.rows-3){
                //controlla in diagonale a destra in alto
                i = 1;
                while(i <= 3 && this.getBoard()[i+row][i+column].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
            if(row>2){
                //controlla in diagonale a destra in basso
                i = 1;
                while(i <= 3 && this.getBoard()[row-i][i+column].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
        }
        if(column>2){
            //controlla a sinistra sulla riga
            i = 1;
            while(i <= 3 && this.getBoard()[row][column-i].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;

            if(row<this.rows-3){
                //controlla in diagonale a sinistra in alto
                i = 1;
                while(i <= 3 && this.getBoard()[i+row][column-i].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
            if(row>2){
                //controlla in diagonale a sinistra in basso
                i = 1;
                while(i <= 3 && this.getBoard()[row-i][column-i].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
        }
        if(row<this.rows-3){
            //controlla in alto sulla colonna
            i = 1;
            while(i <= 3 && this.getBoard()[i+row][column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;
        }
        if(row>2){
            //controlla in basso sulla colonna
            i = 1;
            while(i <= 3 && this.getBoard()[row-i][column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;
        }

        return false;
    }

    /**
     * @deprecated
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWin3(Integer row, Integer column){
        Integer i;

        //CONTROLLO ORIZZONTALE
        i=0;
//        System.out.println("CONTROLLO ORIZZONTALE");
        while((i<4)&&(column+i<this.columns)){
//            System.out.println("ENTRA NEL WHILE");
            if(checkWin(row,column+i,0, -1)) return true;
            i++;
        }

        //CONTROLLO DIAGONALE
        i=0;
//        System.out.println("CONTROLLO DIAGONALE");
        while((i<4)&&(column+i<this.columns)&&(row+i<this.rows)){
//            System.out.println("ENTRA NEL WHILE");
            if(checkWin(row+i,column+i,-1, -1)) return true;
            i++;
        }

        //CONTROLLO ANTIDIAGONALE
//        System.out.println("CONTROLLO ANTIDIAGONALE");
        i=0;
        while((i<4)&&(column+i<this.columns)){
//            System.out.println("ENTRA NEL WHILE");
            if((row-i<this.rows-3)&&(checkWin(row-i,column+i,+1, -1))) return true;
            i++;
        }

        //CONTROLLO VERTICALE
        if(row>2){
            Integer actualPlayer = this.getBoard()[row][column];
            i = 1;
            while(i <= 3 && this.getBoard()[row-i][column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;
        }

        return false;
    }

    /**
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * inoltre aggiorna i valori dell'euristica. Se lo stato raggiunto è
     * uno stato te
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWinWithEuristicValues(Integer row, Integer column){
        Integer playerColor = getCellState(row, column);
//        System.out.println("HASWINWITHHEURISTICVALUES");
        return checkHorizontalWinWithEuristicValues(row, column, playerColor)||
               checkDiagonalWinWithEuristicValues(row, column, playerColor)||
               checkAntiDiagonalWinWithEuristicValues(row, column, playerColor)||
               checkVerticalWinFromStartWithEuristicValues(row, column, playerColor);
//        System.out.println("FINE");
//        return win;
    }

    /**
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * in orizzontale; contemporaneamente aggiorna i valori in heuristicValues
     */
    private Boolean checkHorizontalWinWithEuristicValues(Integer row, Integer column, Integer player){
        Integer i = 0;
        while(i<4 && !checkHorizontalWinFromStartWithEuristicValues(row, column+i, player)) i++;
        if(i.equals(4)) return false;
        return true;
    }

    /**
     * metodo che verifica se c'è un forza quattro in orizzontale a sinistra delle
     * coordinate inserite; contemporaneamente aggiorna i valori in heuristicValues
     */
    private Boolean checkHorizontalWinFromStartWithEuristicValues(Integer row, Integer column, Integer player){
        Integer playerCells = 0;
        Integer opponentCells = 0;

        Integer c;

        //controlla se è possibile effettuare il controllo
        if(column<3 || column>=this.columns || row<0 || row>=this.rows) return false;

        //conteggio delle pedine inserite
        for(c=0;c<4;c++){
            if(this.board[row][column-c].equals(player)) playerCells++;
            else if(this.board[row][column-c].equals((-1)*player)) opponentCells++;
        }

        //Controllo forzaquattro
        if(playerCells.equals(4)) return true;

        updateHeuristicValues(playerCells, opponentCells, player);

        return false;
    }

    /**
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * in diagonale; contemporaneamente aggiorna i valori in heuristicValues
     */
    private Boolean checkDiagonalWinWithEuristicValues(Integer row, Integer column, Integer player){
        Integer i = 0;
        while(i<4 && !checkDiagonalWinFromStartWithEuristicValues(row+i, column-i, player)) i++;
        if(i.equals(4)) return false;
        return true;
    }

    /**
     * metodo che verifica se c'è un forza quattro in diagonale a destra e in basso
     * rispetto alle coordinate inserite; contemporaneamente aggiorna i valori in
     * heuristicValues
     */
    private Boolean checkDiagonalWinFromStartWithEuristicValues(Integer row, Integer column, Integer player){
        Integer playerCells = 0;
        Integer opponentCells = 0;

        Integer c;

        //controlla se è possibile effettuare il controllo
        if(column<0 || column>=this.columns-3 || row<3 || row>=this.rows) return false;

        //conteggio delle pedine inserite
        for(c=0;c<4;c++){
            if(this.board[row-c][column+c].equals(player)) playerCells++;
            else if(this.board[row-c][column+c].equals((-1)*player)) opponentCells++;
        }

        //Controllo forzaquattro
        if(playerCells.equals(4)) return true;

        updateHeuristicValues(playerCells, opponentCells, player);

        return false;
    }

    /**
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * in antidiagonale; contemporaneamente aggiorna i valori in heuristicValues
     */
    private Boolean checkAntiDiagonalWinWithEuristicValues(Integer row, Integer column, Integer player){
        Integer i = 0;
        while(i<4 && !checkAntiDiagonalWinFromStartWithEuristicValues(row+i, column+i, player)) i++;
        if(i.equals(4)) return false;
        return true;
    }

    /**
     * metodo che verifica se c'è un forza quattro in antidiagonale a sinistra e in basso
     * rispetto alle coordinate inserite; contemporaneamente aggiorna i valori in
     * heuristicValues
     */
    private Boolean checkAntiDiagonalWinFromStartWithEuristicValues(Integer row, Integer column, Integer player){
        Integer playerCells = 0;
        Integer opponentCells = 0;

        Integer c;

        //controlla se è possibile effettuare il controllo
        if(column<3 || column>=this.columns || row<3 || row>=this.rows) return false;

        //conteggio delle pedine inserite
        for(c=0;c<4;c++){
            if(this.board[row-c][column-c].equals(player)) playerCells++;
            else if(this.board[row-c][column-c].equals((-1)*player)) opponentCells++;
        }

        //Controllo forzaquattro
        if(playerCells.equals(4)) return true;

        updateHeuristicValues(playerCells, opponentCells, player);

        return false;
    }

    /**
     * metodo che verifica se c'è un forza quattro in verticale in basso
     * rispetto alle coordinate inserite; contemporaneamente aggiorna i valori in
     * heuristicValues
     */
    private Boolean checkVerticalWinFromStartWithEuristicValues(Integer row, Integer column, Integer player){
        Integer playerCells = 0;
        Integer opponentCells = 0;

        Integer c;

        //controlla se è possibile effettuare il controllo
        if(column<0 || column>=this.columns || row<3 || row>=this.rows) return false;

        //conteggio delle pedine inserite
        for(c=0;c<4;c++){
            if(this.board[row-c][column].equals(player)) playerCells++;
            else if(this.board[row-c][column].equals((-1)*player)) opponentCells++;
        }

        //Controllo forzaquattro
        if(playerCells.equals(4)) return true;

        updateHeuristicValues(playerCells, opponentCells, player);

        return false;
    }

    private void updateHeuristicValues(Integer playerCells, Integer opponentCells, Integer player) {
        if (playerCells.equals(3)) {
            /**
             * prima erano 2 ed ora 3
             * se non ci sono pedine avversarie => decrementare playerTwo ed incrementare playerThree
             * se ci sono pedine avversarie => NIENTE
             */
            if (opponentCells.equals(0)) {
                if (player.equals(ControllerInterface.yellow)) {
                    this.getHeuristicValues().setYellowThree(this.getHeuristicValues().getYellowThree() + 1);
                    this.getHeuristicValues().setYellowTwo(this.getHeuristicValues().getYellowTwo() - 1);
                } else {
                    this.getHeuristicValues().setRedThree(this.getHeuristicValues().getRedThree() + 1);
                    this.getHeuristicValues().setRedTwo(this.getHeuristicValues().getRedTwo() - 1);
                }
            }
        } else if (playerCells.equals(2)) {
            /**
             * prima era 1 ed ora 2
             * se non ci sono pedine avversarie => decrementare playerOne ed incrementare playerTwo
             * se ci sono pedine avversarie => NIENTE
             */
            if (opponentCells.equals(0)) {
                if (player.equals(ControllerInterface.yellow)) {
                    this.getHeuristicValues().setYellowTwo(this.getHeuristicValues().getYellowTwo() + 1);
                    this.getHeuristicValues().setYellowOne(this.getHeuristicValues().getYellowOne() - 1);
                } else {
                    this.getHeuristicValues().setRedTwo(this.getHeuristicValues().getRedTwo() + 1);
                    this.getHeuristicValues().setRedOne(this.getHeuristicValues().getRedOne() - 1);
                }
            }
        } else if (playerCells.equals(1)) {
            /**
             * prima erano 0 ed ora 1
             * se non ci sono pedine avversarie => incrementare playerOne
             * se c'è una pedina avversaria => decrementare opponentOne
             * se ci sono due pedine avversarie => decrementare opponentTwo
             * se ci sono tre pedine avversarie => decrementare opponentThree
             */
            if (opponentCells.equals(0)) {
                if (player.equals(ControllerInterface.yellow)) {
                    this.getHeuristicValues().setYellowOne(this.getHeuristicValues().getYellowOne() + 1);
                } else {
                    this.getHeuristicValues().setRedOne(this.getHeuristicValues().getRedOne() + 1);
                }
            } else if (opponentCells.equals(1)) {
                if (player.equals(ControllerInterface.yellow)) {
                    this.getHeuristicValues().setRedOne(this.getHeuristicValues().getYellowOne() - 1);
                } else {
                    this.getHeuristicValues().setYellowOne(this.getHeuristicValues().getRedOne() - 1);
                }
            } else if (opponentCells.equals(2)) {
                if (player.equals(ControllerInterface.yellow)) {
                    this.getHeuristicValues().setRedTwo(this.getHeuristicValues().getYellowTwo() - 1);
                } else {
                    this.getHeuristicValues().setYellowTwo(this.getHeuristicValues().getRedTwo() - 1);
                }
            } else if (opponentCells.equals(3)) {
                if (player.equals(ControllerInterface.yellow)) {
                    this.getHeuristicValues().setRedThree(this.getHeuristicValues().getYellowThree() - 1);
                } else {
                    this.getHeuristicValues().setYellowThree(this.getHeuristicValues().getRedThree() - 1);
                }
            }
        }
    }

    /**
     * @deprecated metodo che verifica se la mossa effettuata ha determinato una vittoria
     * utilizzare hasWinWithHeuristicValues
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWin(Integer row, Integer column){
        Integer i;

        //CONTROLLO ORIZZONTALE
        i=0;
        while(i<4){
            if(checkHorizontalWin(row,column+i)) return true;
            i++;
        }

        //CONTROLLO DIAGONALE
        i=0;
        while(i<4){
//            System.out.println("ENTRA NEL WHILE");
            if(checkDiagonalWin(row+i,column+i)) return true;
            i++;
        }

        //CONTROLLO ANTIDIAGONALE
        i=0;
        while(i<4){
            if(checkAntiDiagonalWin(row-i,column+i)) return true;
            i++;
        }

        //CONTROLLO VERTICALE
        if(checkVerticalWin(row,column)) return true;

        return false;
    }

    /**
     * metodo per il controllo del forza quattro in orizzontale. A partire dalle
     * coordinate inserite verifica che le 3 celle a sinistra e in basso
     * abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la colonna
     *   è tale che la funzione non è applicabile
     * - se nelle quattro colonne a partire dalla cella [x][y] verso sinistra non
     *   si trova un forza quattro
     */
    private Boolean checkHorizontalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida, e quindi un intero tra 0 e this.rows
         * - y deve essere una colonna valida a cui è applicabile la funzione
         *   e quindi deve essere compreso tra 3 e this.columns
         */
        if(x<0 || x>=this.rows || y<3 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sulla riga
        i = 1;
        while(i < 4 && this.getBoard()[x][y-i].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }
    
    /**
     * metodo per il controllo del forza quattro in diagonale. A partire dalle
     * coordinate inserite verifica che le 3 celle a sinistra sulla stessa riga
     * abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la riga 
     *   (o la colonna) è tale che la funzione non è applicabile
     * - se nelle quattro colonne a partire dalla cella [x][y] verso sinistra non
     *   si trova un forza quattro
     */
    private Boolean checkDiagonalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida a cui è applicabile la funzione
         *   e quindi un intero tra 3 e this.rows
         * - y deve essere una colonna valida a cui è applicabile la funzione
         *   e quindi deve essere compreso tra 3 e this.columns
         */
        if(x<3 || x>=this.rows || y<3 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sulla diagonale
        i = 1;
        while(i < 4 && this.getBoard()[x-i][y-i].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }

    /**
     * metodo per il controllo del forza quattro in antidiagonale. A partire dalle
     * coordinate inserite verifica che le 3 celle a sinistra e verso l'alto
     * abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la riga
     *   (o colonna) inserita è tale che la funzione non è applicabile.
     * - se nelle quattro colonne a partire dalla cella [x][y] verso sinistra
     *   e verso l'alto non si trova un forza quattro
     */
    private Boolean checkAntiDiagonalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida a cui è applicabile la funzione
         *   e quindi un intero tra 0 e this.rows-3
         * - y deve essere una colonna valida a cui è applicabile la funzione
         *   e quindi deve essere compreso tra 3 e this.columns
         */
        if(x<0 || x>=this.rows-3 || y<3 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sull'antidiagonale
        i = 1;
        while(i < 4 && this.getBoard()[x+i][y-i].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }


    /**
     * metodo per il controllo del forza quattro in verticale. A partire dalle
     * coordinate inserite verifica che le 3 celle in basso abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la riga
     *   è tale che la funzione non è applicabile
     * - se nelle quattro colonne a partire dalla cella [x][y] verso il basso non
     *   si trova un forza quattro
     */
    private Boolean checkVerticalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida a cui è applicabile la funzione
         *   e quindi un intero tra 3 e this.rows
         * - y deve essere una colonna valida, e quindi deve essere compreso tra
         *   0 e this.columns
         */
        if(x<3 || x>=this.rows || y<0 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sulla colonna
        i = 1;
        while(i < 4 && this.getBoard()[x-i][y].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }

    /**
     * @deprecated
     * @param x
     * @param y
     * @param dirX
     * @param dirY
     * @return
     */
    private Boolean checkWin(Integer x, Integer y, Integer dirX, Integer dirY){
        Integer actualPlayer;
        Integer i;

        if(x<0 || y<0) return false;
        
        actualPlayer = this.getBoard()[x][y];
//        System.out.println("CELLA LETTA (ACTUALPLAYER) ["+x+";"+y+"] = "+actualPlayer);
        i = 1;
        while(i <= 3 &&
              x+(i*dirX)>=0 &&
              y+(i*dirY)>=0 &&
              this.getBoard()[x+(i*dirX)][y+(i*dirY)].equals(actualPlayer))
        {
//            System.out.println("CELLA LETTA ["+(x+(firstFreeRow*dirX))+";"+(y+(firstFreeRow*dirY))+"] = "+this.board[x+(firstFreeRow*dirX)][y+(firstFreeRow*dirY)]);
            i++;
        }

        if (i.equals(4)) return true;
        return false;
    }

    /**
     * metodo per conoscere lo stato di una cella di gioco
     * @param row riga della cella di cui si vuole conoscere lo stato
     * @param column colonna della cella di cui si vuole conoscere lo stato
     * @return lo stato della cella board[row][column]
     */
    public Integer getCellState(Integer row, Integer column){
        return this.getBoard()[row][column];
    }

    /**
     * metodo privato per l'inizializzazione delle celle della matrice board
     */
    private void initializes(){
        for(Integer i = 0; i < this.rows; i++){
            for(Integer j = 0; j < this.columns; j++){
                this.board[i][j] = 0;
            }
        }
        for(Integer j = 0; j < this.columns; j++){
            this.firstFreeCellForColumn[j] = 0;
        }
    }

    @Override
    public String toString(){
        String gameState = "\nSTATO DEL GIOCO\n";
        for(Integer i = 0; i < this.rows; i++){
            for(Integer j = 0; j < this.columns; j++){
               gameState+="["+this.getBoard()[i][j]+"]";
            }
            gameState+="\n";
        }
        return gameState;
    }

    @Override
    protected GameState clone() throws CloneNotSupportedException {
        GameState gs = new GameState(this.getRows(),this.getColumns());
        gs.setWinner(this.winner);
        gs.setPlayer(this.player); //il giocatore che ha fatto l'ultima mossa
        gs.setMove(this.move);   //ultima mossa effettuata
        gs.setFreeCells(this.freeCells);
        for(Integer i = 0; i < this.rows; i++){
            for(Integer j = 0; j < this.columns; j++){
                gs.board[i][j] = this.getCellState(i, j);
            }
        }
        for(Integer j = 0; j < this.columns; j++){
            gs.firstFreeCellForColumn[j] = this.firstFreeCellForColumn[j];
        }
        return gs;
    }

    private void setFreeCells(Integer freeCells) {
        this.freeCells = freeCells;
    }

    private Integer getFreeCells() {
        return freeCells;
    }

    public Boolean isTerminal(){
        return(this.winner!=2);
    }

    /**
     * @return the board
     */
    private Integer[][] getBoard() {
        return board;
    }

    /**
     * @return the heuristicValues
     */
    public HeuristicValues getHeuristicValues() {
        return heuristicValues;
    }

}

class HeuristicValues implements Cloneable {
    private Integer yellowOne;
    private Integer yellowTwo;
    private Integer yellowThree;
    private Integer redOne;
    private Integer redTwo;
    private Integer redThree;

    public HeuristicValues(){
        this(0,0,0,0,0,0);
    }
    
    public HeuristicValues(Integer yellowOne, Integer yellowTwo, Integer yellowThree, Integer redOne, Integer redTwo, Integer redThree){
        setYellowOne(yellowOne);
        setYellowTwo(yellowTwo);
        setYellowThree(yellowThree);
        setRedOne(redOne);
        setRedTwo(redTwo);
        setRedThree(redThree);
    }

    /**
     * @return the yellowOne
     */
    public Integer getYellowOne() {
        return yellowOne;
    }

    /**
     * @param yellowOne the yellowOne to set
     */
    public void setYellowOne(Integer yellowOne) {
        this.yellowOne = yellowOne;
    }

    /**
     * @return the yellowTwo
     */
    public Integer getYellowTwo() {
        return yellowTwo;
    }

    /**
     * @param yellowTwo the yellowTwo to set
     */
    public void setYellowTwo(Integer yellowTwo) {
        this.yellowTwo = yellowTwo;
    }

    /**
     * @return the yellowThree
     */
    public Integer getYellowThree() {
        return yellowThree;
    }

    /**
     * @param yellowThree the yellowThree to set
     */
    public void setYellowThree(Integer yellowThree) {
        this.yellowThree = yellowThree;
    }

    /**
     * @return the redOne
     */
    public Integer getRedOne() {
        return redOne;
    }

    /**
     * @param redOne the redOne to set
     */
    public void setRedOne(Integer redOne) {
        this.redOne = redOne;
    }

    /**
     * @return the redTwo
     */
    public Integer getRedTwo() {
        return redTwo;
    }

    /**
     * @param redTwo the redTwo to set
     */
    public void setRedTwo(Integer redTwo) {
        this.redTwo = redTwo;
    }

    /**
     * @return the redThree
     */
    public Integer getRedThree() {
        return redThree;
    }

    /**
     * @param redThree the redThree to set
     */
    public void setRedThree(Integer redThree) {
        this.redThree = redThree;
    }

    @Override
    protected HeuristicValues clone(){
       return new HeuristicValues(yellowOne, yellowTwo, yellowThree, redOne, redTwo, redThree);
    }
}
