package connectFour;
/**
 * GameState.java
 *
 * File generated from the ConnectFour::GameState uml Class
 * Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
 * $ Date : 23/04/10 15.19.33 (23 aprile 2010) $
 */

/**
 * Description of the class GameState.
 *
 */

/**
 * @author barnap
 *
 */
public class GameState implements Cloneable{

	/**
	 * Matrice di interi che rappresenta il tavolo di gioco.
	 * Ogni cella della matrice può contenere un valore tra:
	 * 0 => cella vuota;
	 * 1 => cella occupata da una pedina del giocatore giallo;
	 * -1 => cella occupata da una pedina del giocatore rosso;
	 */
	private Integer[][] board;
	private Integer rows;
	private Integer columns;
	private Integer winner;
	private Integer player; //il giocatore che ha fatto l'ultima mossa
	private Integer move;   //ultima mossa effettuata
	private Integer freeCells;  //numero di celle libere

	public GameState(){
		this(8,7);
	}

	public GameState(Integer rows, Integer columns){
		setRows(rows);
		setColumns(columns);
		setWinner(2);
		setPlayer(0);
		setMove(-1);
		setFreeCells(rows*columns);
		board = new Integer[rows][columns];
		initializes();
	}

	public Integer getRows() {
		return rows;
	}

	private void setRows(Integer rows) {
		this.rows = rows;
	}

	public Integer getColumns() {
		return columns;
	}

	private void setColumns(Integer columns) {
		this.columns = columns;
	}

	/**
	 * metodo per la verifica del vincitore
	 * @return
	 * -1 => ha vinto il giocatore rosso;
	 * 0 => la partita è finita in pareggio;
	 * 1 => ha vinto il giocatore giallo;
	 * 2 => la partita non è ancora finita;
	 */
	public Integer getWinner() {
		return winner;
	}

	private void setWinner(Integer winner) {
		this.winner = winner;
	}

	public Integer getMove(){
		return move;
	}

	private void setPlayer(Integer player) {
		this.player = player;
	}

	public Integer getPlayer() {
		return player;
	}

	private void setMove(Integer move) {
		this.move = move;
	}
	/**
	 * metodo per effettuare le giocate
	 * @param player intero che rappresenta il giocatore di turno
	 * @param column intero che rappresenta la colonna scelta dal giocatore
	 * @return true se la mossa è stata effettuata con successo, false altrimenti
	 */
	public Boolean doMove(Integer player, Integer column){
		Integer i=0;
		if(this.isTerminal()){
			System.out.println("Mossa non consentita - PARTITA TERMINATA");
			return false;
		}
		while(i<this.rows && !this.board[i][column].equals(0)) i++;
		if(i==this.rows){
			System.out.println("Mossa non consentita - COLONNA PIENA");
			return false;
		}
		board[i][column]=player;
		this.setPlayer(player);
		this.setMove(column);
		this.setFreeCells(this.freeCells-1);
                if(hasWin(i, column))setWinner(player);
                else if(this.freeCells==0)setWinner(0);
		//this.stampa();
		return true;
	}

	private Boolean hasWin(Integer row, Integer column){
		Integer actualPlayer=this.board[row][column];
		Integer i;

		if(column<this.columns-3){
			//controlla a destra sulla riga
			i = 1;
			while(i <= 3 && this.board[row][i+column].equals(actualPlayer)) i++;
			if (i.equals(4)) return true;

			if(row<this.rows-3){
				//controlla in diagonale a destra in alto
				i = 1;
				while(i <= 3 && this.board[i+row][i+column].equals(actualPlayer)) i++;
				if (i.equals(4)) return true;
			}
			if(row>2){
				//controlla in diagonale a destra in basso
				i = 1;
				while(i <= 3 && this.board[row-i][i+column].equals(actualPlayer)) i++;
				if (i.equals(4)) return true;
			}
		}
		if(column>2){
			//controlla a sinistra sulla riga
			i = 1;
			while(i <= 3 && this.board[row][column-i].equals(actualPlayer)) i++;
			if (i.equals(4)) return true;
			if(row<this.rows-3){
				//controlla in diagonale a sinistra in alto
				i = 1;
				while(i <= 3 && this.board[i+row][column-i].equals(actualPlayer)) i++;
				if (i.equals(4)) return true;
			}
			if(row>2){
				//controlla in diagonale a sinistra in basso
				i = 1;
				while(i <= 3 && this.board[row-i][column-i].equals(actualPlayer)) i++;
				if (i.equals(4)) return true;
			}
		}
		if(row<this.rows-3){
			//controlla in alto sulla colonna
			i = 1;
			while(i <= 3 && this.board[i+row][column].equals(actualPlayer)) i++;
			if (i.equals(4)) return true;
		}
		if(row>2){
			//controlla in basso sulla colonna
			i = 1;
			while(i <= 3 && this.board[row-i][column].equals(actualPlayer)) i++;
			if (i.equals(4)) return true;
		}

		return false;
	}

	/**
	 * metodo per conoscere lo stato di una cella di gioco
	 * @param row
	 * @param column
	 * @return lo stato della cella [row,column]
	 */
	public Integer getCellState(Integer row, Integer column){
		return this.board[row][column];
	}

	private void initializes(){
		for(Integer i = 0; i < this.rows; i++){
			for(Integer j = 0; j < this.columns; j++){
				this.board[i][j] = 0;
			}
		}
	}

	public void stampa(){
		System.out.println("\nSTAMPA DI CONTROLLO");
		for(Integer i = 0; i < this.rows; i++){
			for(Integer j = 0; j < this.columns; j++){
				System.out.print("["+this.board[i][j]+"]");
			}
			System.out.println();
		}
	}

	private void setFreeCells(Integer freeCells) {
		this.freeCells = freeCells;
	}

	private Integer getFreeCells() {
		return freeCells;
	}

        public Boolean isTerminal(){
            return(this.winner!=2);
        }

    @Override
    protected GameState clone() throws CloneNotSupportedException {
        GameState gs = new GameState(this.getRows(),this.getColumns());
	gs.setWinner(this.winner);
	gs.setPlayer(this.player); //il giocatore che ha fatto l'ultima mossa
	gs.setMove(this.move);   //ultima mossa effettuata
	gs.setFreeCells(this.freeCells);
        for(Integer i = 0; i < this.rows; i++){
                for(Integer j = 0; j < this.columns; j++){
                        gs.board[i][j] = this.getCellState(i, j);
                }
        }
        return gs;
    }
}
