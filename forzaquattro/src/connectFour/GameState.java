package connectFour;
/**
 * GameState.java
 *
 * File generated from the ConnectFour::GameState uml Class
 * Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
 * $ Date : 23/04/10 15.19.33 (23 aprile 2010) $
 */

/**
 * Description of the class GameState.
 * classe che tiene traccia dello stato del gioco
 */

/**
 * @author barnap
 *
 */
public class GameState implements Cloneable{

    /**
     * l'attributo board è una Matrice di interi che rappresenta il tavolo di gioco.
     * Ogni cella della matrice può contenere un valore tra:
     * 0 => cella vuota;
     * 1 => cella occupata da una pedina del giocatore giallo;
     * -1 => cella occupata da una pedina del giocatore rosso;
     */
    private Integer[][] board;
    private Integer rows;       // numero di righe della tabella
    private Integer columns;    // numero di colonne della tabella
    private Integer winner;     // intero che individua il vincitore della partita;
    private Integer player;     // intero che individua il giocatore che ha effettuato l'ultima mossa
    private Integer move;       // intero che individua l'ultima mossa effettuata
    private Integer freeCells;  // numero di celle libere

    /**
     * Constructor.
     */
    public GameState(){
        this(8,7);
    }

    public GameState(Integer rows, Integer columns){
        setRows(rows);
        setColumns(columns);
        setWinner(2);
        setPlayer(0);
        setMove(-1);
        setFreeCells(rows*columns);
        board = new Integer[rows][columns];
        initializes();
    }

    public Integer getRows() {
        return rows;
    }

    private void setRows(Integer rows) {
        this.rows = rows;
    }

    public Integer getColumns() {
        return columns;
    }

    private void setColumns(Integer columns) {
        this.columns = columns;
    }

    /**
     * metodo per la verifica del vincitore
     * @return
     * -1 => ha vinto il giocatore rosso;
     * 0 => la partita è finita in pareggio;
     * 1 => ha vinto il giocatore giallo;
     * 2 => la partita non è ancora finita;
     */
    public Integer getWinner() {
        return winner;
    }

    private void setWinner(Integer winner) {
        this.winner = winner;
    }

    public Integer getMove(){
        return move;
    }

    private void setPlayer(Integer player) {
        this.player = player;
    }

    public Integer getPlayer() {
        return player;
    }

    private void setMove(Integer move) {
        this.move = move;
    }

    /**
     * metodo per effettuare le giocate
     * @param player intero che rappresenta il giocatore di turno
     * @param column intero che rappresenta la colonna scelta dal giocatore
     * @return true se la mossa è stata effettuata con successo, false altrimenti
     */
    public Boolean doMove(Integer player, Integer column){
        Integer i=0;
        // se lo stato è terminale non sono applicabili altre mosse
        if(this.isTerminal()) return false;

        // cerca la riga in cui inserire la pedina nella colonna specificata
        while(i<this.rows && !this.board[i][column].equals(0)) i++;

        // se la colonna è già piena non è possibile effettuare la mossa desiderata
        if(i==this.rows) return false;

        //effettua la mossa e aggiorna lo stato del gioco
        board[i][column]=player;
        this.setPlayer(player);
        this.setMove(column);
        this.setFreeCells(this.freeCells-1);

        /* se c'è un vincitore oppure la partita è finita in pareggioaggiorna la
         * variabile winner
         */
        if(hasWin(i, column))setWinner(player);
        else if(this.freeCells==0)setWinner(0);

        return true;
    }

    /**
     * @deprecated
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWin2(Integer row, Integer column){
        Integer actualPlayer=this.getBoard()[row][column];
        Integer i;

        if(column<this.columns-3){
            //controlla a destra sulla riga
            i = 1;
            while(i <= 3 && this.getBoard()[row][i+column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;

            if(row<this.rows-3){
                //controlla in diagonale a destra in alto
                i = 1;
                while(i <= 3 && this.getBoard()[i+row][i+column].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
            if(row>2){
                //controlla in diagonale a destra in basso
                i = 1;
                while(i <= 3 && this.getBoard()[row-i][i+column].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
        }
        if(column>2){
            //controlla a sinistra sulla riga
            i = 1;
            while(i <= 3 && this.getBoard()[row][column-i].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;

            if(row<this.rows-3){
                //controlla in diagonale a sinistra in alto
                i = 1;
                while(i <= 3 && this.getBoard()[i+row][column-i].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
            if(row>2){
                //controlla in diagonale a sinistra in basso
                i = 1;
                while(i <= 3 && this.getBoard()[row-i][column-i].equals(actualPlayer)) i++;
                if (i.equals(4)) return true;
            }
        }
        if(row<this.rows-3){
            //controlla in alto sulla colonna
            i = 1;
            while(i <= 3 && this.getBoard()[i+row][column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;
        }
        if(row>2){
            //controlla in basso sulla colonna
            i = 1;
            while(i <= 3 && this.getBoard()[row-i][column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;
        }

        return false;
    }

    /**
     * @deprecated
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWin3(Integer row, Integer column){
        Integer i;

        //CONTROLLO ORIZZONTALE
        i=0;
//        System.out.println("CONTROLLO ORIZZONTALE");
        while((i<4)&&(column+i<this.columns)){
//            System.out.println("ENTRA NEL WHILE");
            if(checkWin(row,column+i,0, -1)) return true;
            i++;
        }

        //CONTROLLO DIAGONALE
        i=0;
//        System.out.println("CONTROLLO DIAGONALE");
        while((i<4)&&(column+i<this.columns)&&(row+i<this.rows)){
//            System.out.println("ENTRA NEL WHILE");
            if(checkWin(row+i,column+i,-1, -1)) return true;
            i++;
        }

        //CONTROLLO ANTIDIAGONALE
//        System.out.println("CONTROLLO ANTIDIAGONALE");
        i=0;
        while((i<4)&&(column+i<this.columns)){
//            System.out.println("ENTRA NEL WHILE");
            if((row-i<this.rows-3)&&(checkWin(row-i,column+i,+1, -1))) return true;
            i++;
        }

        //CONTROLLO VERTICALE
        if(row>2){
            Integer actualPlayer = this.getBoard()[row][column];
            i = 1;
            while(i <= 3 && this.getBoard()[row-i][column].equals(actualPlayer)) i++;
            if (i.equals(4)) return true;
        }

        return false;
    }

    /**
     * metodo che verifica se la mossa effettuata ha determinato una vittoria
     * @param row riga della cella in cui è stata inserita l'ultima pedina
     * @param column colonna della cella in cui è stata inserita l'ultima pedina
     * @return true se la mossa ha determinato una vittoria; false altrimenti
     */
    private Boolean hasWin(Integer row, Integer column){
        Integer i;

        //CONTROLLO ORIZZONTALE
        i=0;
        while(i<4){
            if(checkHorizontalWin(row,column+i)) return true;
            i++;
        }

        //CONTROLLO DIAGONALE
        i=0;
        while(i<4){
//            System.out.println("ENTRA NEL WHILE");
            if(checkDiagonalWin(row+i,column+i)) return true;
            i++;
        }

        //CONTROLLO ANTIDIAGONALE
        i=0;
        while(i<4){
            if(checkAntiDiagonalWin(row-i,column+i)) return true;
            i++;
        }

        //CONTROLLO VERTICALE
        if(checkVerticalWin(row,column)) return true;

        return false;
    }

    /**
     * metodo per il controllo del forza quattro in orizzontale. A partire dalle
     * coordinate inserite verifica che le 3 celle a sinistra e in basso
     * abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la colonna
     *   è tale che la funzione non è applicabile
     * - se nelle quattro colonne a partire dalla cella [x][y] verso sinistra non
     *   si trova un forza quattro
     */
    private Boolean checkHorizontalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida, e quindi un intero tra 0 e this.rows
         * - y deve essere una colonna valida a cui è applicabile la funzione
         *   e quindi deve essere compreso tra 3 e this.columns
         */
        if(x<0 || x>=this.rows || y<3 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sulla riga
        i = 1;
        while(i < 4 && this.getBoard()[x][y-i].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }
    
    /**
     * metodo per il controllo del forza quattro in diagonale. A partire dalle
     * coordinate inserite verifica che le 3 celle a sinistra sulla stessa riga
     * abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la riga 
     *   (o la colonna) è tale che la funzione non è applicabile
     * - se nelle quattro colonne a partire dalla cella [x][y] verso sinistra non
     *   si trova un forza quattro
     */
    private Boolean checkDiagonalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida a cui è applicabile la funzione
         *   e quindi un intero tra 3 e this.rows
         * - y deve essere una colonna valida a cui è applicabile la funzione
         *   e quindi deve essere compreso tra 3 e this.columns
         */
        if(x<3 || x>=this.rows || y<3 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sulla diagonale
        i = 1;
        while(i < 4 && this.getBoard()[x-i][y-i].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }

    /**
     * metodo per il controllo del forza quattro in antidiagonale. A partire dalle
     * coordinate inserite verifica che le 3 celle a sinistra e verso l'alto
     * abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la riga
     *   (o colonna) inserita è tale che la funzione non è applicabile.
     * - se nelle quattro colonne a partire dalla cella [x][y] verso sinistra
     *   e verso l'alto non si trova un forza quattro
     */
    private Boolean checkAntiDiagonalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida a cui è applicabile la funzione
         *   e quindi un intero tra 0 e this.rows-3
         * - y deve essere una colonna valida a cui è applicabile la funzione
         *   e quindi deve essere compreso tra 3 e this.columns
         */
        if(x<0 || x>=this.rows-3 || y<3 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sull'antidiagonale
        i = 1;
        while(i < 4 && this.getBoard()[x+i][y-i].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }


    /**
     * metodo per il controllo del forza quattro in verticale. A partire dalle
     * coordinate inserite verifica che le 3 celle in basso abbiano lo stesso valore
     * @param x riga di partenza
     * @param y colonna di partenza
     * @return true se trova il forza quattro; false nei seguenti casi:
     * - se le coordinate inserite non sono valide; ciò avviene se la riga o
     *   la colonna inserita è fuori dai limiti della matrice oppure se la riga
     *   è tale che la funzione non è applicabile
     * - se nelle quattro colonne a partire dalla cella [x][y] verso il basso non
     *   si trova un forza quattro
     */
    private Boolean checkVerticalWin(Integer x, Integer y){
        Integer actualPlayer;
        Integer i;

        /**
         * controllo sulle coordinate inserite:
         * - x deve essere una riga valida a cui è applicabile la funzione
         *   e quindi un intero tra 3 e this.rows
         * - y deve essere una colonna valida, e quindi deve essere compreso tra
         *   0 e this.columns
         */
        if(x<3 || x>=this.rows || y<0 || y>=this.columns) return false;

        // lettura del colore della cella inserita
        actualPlayer = this.getBoard()[x][y];

        // controllo forza quattro sulla colonna
        i = 1;
        while(i < 4 && this.getBoard()[x-i][y].equals(actualPlayer)) i++;
        if (i.equals(4)) return true;

        return false;
    }

    /**
     * @deprecated
     * @param x
     * @param y
     * @param dirX
     * @param dirY
     * @return
     */
    private Boolean checkWin(Integer x, Integer y, Integer dirX, Integer dirY){
        Integer actualPlayer;
        Integer i;

        if(x<0 || y<0) return false;
        
        actualPlayer = this.getBoard()[x][y];
//        System.out.println("CELLA LETTA (ACTUALPLAYER) ["+x+";"+y+"] = "+actualPlayer);
        i = 1;
        while(i <= 3 &&
              x+(i*dirX)>=0 &&
              y+(i*dirY)>=0 &&
              this.getBoard()[x+(i*dirX)][y+(i*dirY)].equals(actualPlayer))
        {
//            System.out.println("CELLA LETTA ["+(x+(i*dirX))+";"+(y+(i*dirY))+"] = "+this.board[x+(i*dirX)][y+(i*dirY)]);
            i++;
        }

        if (i.equals(4)) return true;
        return false;
    }

    /**
     * metodo per conoscere lo stato di una cella di gioco
     * @param row riga della cella di cui si vuole conoscere lo stato
     * @param column colonna della cella di cui si vuole conoscere lo stato
     * @return lo stato della cella board[row][column]
     */
    public Integer getCellState(Integer row, Integer column){
        return this.getBoard()[row][column];
    }

    /**
     * metodo privato per l'inizializzazione delle celle della matrice board
     */
    private void initializes(){
        for(Integer i = 0; i < this.rows; i++){
            for(Integer j = 0; j < this.columns; j++){
                this.board[i][j] = 0;
            }
        }
    }

    @Override
    public String toString(){
        String gameState = "\nSTATO DEL GIOCO\n";
        for(Integer i = 0; i < this.rows; i++){
            for(Integer j = 0; j < this.columns; j++){
               gameState+="["+this.getBoard()[i][j]+"]";
            }
            gameState+="\n";
        }
        return gameState;
    }

    private void setFreeCells(Integer freeCells) {
            this.freeCells = freeCells;
    }

    private Integer getFreeCells() {
            return freeCells;
    }

    public Boolean isTerminal(){
        return(this.winner!=2);
    }

    @Override
    protected GameState clone() throws CloneNotSupportedException {
        GameState gs = new GameState(this.getRows(),this.getColumns());
        gs.setWinner(this.winner);
        gs.setPlayer(this.player); //il giocatore che ha fatto l'ultima mossa
        gs.setMove(this.move);   //ultima mossa effettuata
        gs.setFreeCells(this.freeCells);
        for(Integer i = 0; i < this.rows; i++){
            for(Integer j = 0; j < this.columns; j++){
                gs.board[i][j] = this.getCellState(i, j);
            }
        }
        return gs;
    }

    /**
     * @return the board
     */
    public Integer[][] getBoard() {
        return board;
    }

}